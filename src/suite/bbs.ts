import {
  type Credential,
  Cryptosuite,
  type JsonLdDocument,
  type LoadDocumentCallback,
  type Proof,
  type URNScheme,
  type Verification,
} from "@herculas/vc-data-integrity"

import type { Feature } from "../constant/feature.ts"

import * as core from "./core.ts"
import * as SUITE_CONSTANT from "../constant/suite.ts"

/**
 * A cryptographic suite for the purpose of creating, verifying, and deriving proofs using the BBS Signature Scheme in
 * conformance with the Data Integrity specification.
 *
 * The BBS Signature Scheme directly provides for selective disclosure and unlinkable proofs. It provides 4 high-level
 * functions that work within the issuer, holder, and verifier model. Specifically, an issuer uses the BBS `sign`
 * function to create a cryptographic value known as a "BBS signature" which is used in signing the original credential.
 * A holder, on receipt of a credential signed with BBS, then verifies the credential with the BBS `verify` function.
 *
 * The holder then chooses information to selectively disclose from the received credential and uses the BBS `ProofGen`
 * function to generate a cryptographic value, known as a "BBS proof", which is used in creating a proof for this
 * "derived credential". The cryptographic "BBS proof" value is not linkable to the original "BBS signature", and a
 * different, unlinkable "BBS proof" can be generated by the holder for additional "derived credentials", including any
 * containing the exact same information. Finally, a verifier uses the BBS `ProofVerify` function to verify the derived
 * credential received from the holder.
 *
 * @see https://www.w3.org/TR/vc-di-bbs/#bbs-2023
 */
export class Bbs2023 extends Cryptosuite {
  /**
   * The name of the cryptographic suite.
   *
   * In this suite, this value MUST be `bbs-2023`.
   */
  static override readonly cryptosuite: string = SUITE_CONSTANT.SUITE_BBS

  /**
   * Create a base data integrity proof given an unsecured data document.
   *
   * @param {JsonLdDocument} unsecuredDocument An unsecured data document to create a proof for.
   * @param {object} options A set of options to use when creating the proof.
   *
   * @returns {Promise<Proof>} Resolve to a base data integrity proof.
   *
   * @see https://www.w3.org/TR/vc-di-bbs/#create-base-proof-bbs-2023
   */
  static override async createProof(
    unsecuredDocument: JsonLdDocument,
    options: {
      feature: Feature
      proof: Proof
      mandatoryPointers: Array<string>
      documentLoader: LoadDocumentCallback
      urnScheme?: URNScheme
      randomString?: string
      commitmentWithProof?: string
      signerNymEntropy?: string
    },
  ): Promise<Proof> {
    // Procedure:
    //
    // 1. Let `proof` be a clone of the proof options, `options`.
    // 2. Let `proofConfig` be the result of running the Base Proof Configuration (bbs-2023) algorithm with `options`
    //    passed as a parameter.
    // 3. Let `transformedData` be the result of running the Base Proof Transformation (bbs-2023) algorithm with
    //    `unsecuredDocument`, `proofConfig`, and `options` passed as parameters.
    // 4. Let `hashData` be the result of running the Base Proof Hashing (bbs-2023) algorithm with `transformedData` and
    //    `proofConfig` passed as parameters.
    // 5. Let `proofBytes` be the result of running the Base Proof Serialization (bbs-2023) algorithm with `hashData`,
    //    `options`, `featureOption`, and, if required, `commitment_with_proof` passed as parameters.
    // 6. Let `proof.proofValue` be a base64url-encoded Multibase value of the `proofBytes`.
    // 7. Return `proof` as the data integrity proof.

    const proof = structuredClone(options.proof)
    const proofConfig = await core.config(unsecuredDocument as Credential, options)
    const transformedData = await core.transform(unsecuredDocument as Credential, options)
    const hashData = await core.hash(transformedData, proofConfig)
    const proofValue = await core.serialize(hashData, options)
    proof.proofValue = proofValue
    return proof
  }

  /**
   * Create a selective disclosure derived proof. The derived proof is to be given to the verifier.
   *
   * @param {JsonLdDocument} securedDocument A secured data document to derive a proof from, with a base proof in it.
   * @param {object} options A set of options to use when deriving the proof.
   *
   * @returns {Promise<Proof>} Resolve to a selective disclosure derived proof.
   *
   * @see https://www.w3.org/TR/vc-di-bbs/#add-derived-proof-bbs-2023
   */
  static override deriveProof(securedDocument: JsonLdDocument, options?: object): Promise<Proof> {
    throw new Error("Method not implemented.")
  }

  /**
   * Verify a data integrity proof given a secured data document.
   *
   * @param {JsonLdDocument} securedDocument A secured data document to verify a proof for.
   * @param {object} options A set of options to use when verifying the proof.
   *
   * @returns {Promise<Verification>} Resolve to a verification result.
   */
  static override verifyProof(securedDocument: JsonLdDocument, options?: object): Promise<Verification> {
    throw new Error("Method not implemented.")
  }
}
